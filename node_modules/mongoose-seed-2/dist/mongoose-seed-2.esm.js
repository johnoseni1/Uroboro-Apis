import mongoose from 'mongoose';
import chalk from 'chalk';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

// A type of promise-like that resolves synchronously and supports only one observer
const _Pact = /*#__PURE__*/(function() {
	function _Pact() {}
	_Pact.prototype.then = function(onFulfilled, onRejected) {
		const result = new _Pact();
		const state = this.s;
		if (state) {
			const callback = state & 1 ? onFulfilled : onRejected;
			if (callback) {
				try {
					_settle(result, 1, callback(this.v));
				} catch (e) {
					_settle(result, 2, e);
				}
				return result;
			} else {
				return this;
			}
		}
		this.o = function(_this) {
			try {
				const value = _this.v;
				if (_this.s & 1) {
					_settle(result, 1, onFulfilled ? onFulfilled(value) : value);
				} else if (onRejected) {
					_settle(result, 1, onRejected(value));
				} else {
					_settle(result, 2, value);
				}
			} catch (e) {
				_settle(result, 2, e);
			}
		};
		return result;
	};
	return _Pact;
})();

// Settles a pact synchronously
function _settle(pact, state, value) {
	if (!pact.s) {
		if (value instanceof _Pact) {
			if (value.s) {
				if (state & 1) {
					state = value.s;
				}
				value = value.v;
			} else {
				value.o = _settle.bind(null, pact, state);
				return;
			}
		}
		if (value && value.then) {
			value.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));
			return;
		}
		pact.s = state;
		pact.v = value;
		const observer = pact.o;
		if (observer) {
			observer(pact);
		}
	}
}

function _isSettledPact(thenable) {
	return thenable instanceof _Pact && thenable.s & 1;
}

// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)
function _forTo(array, body, check) {
	var i = -1, pact, reject;
	function _cycle(result) {
		try {
			while (++i < array.length && (!check || !check())) {
				result = body(i);
				if (result && result.then) {
					if (_isSettledPact(result)) {
						result = result.v;
					} else {
						result.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));
						return;
					}
				}
			}
			if (pact) {
				_settle(pact, 1, result);
			} else {
				pact = result;
			}
		} catch (e) {
			_settle(pact || (pact = new _Pact()), 2, e);
		}
	}
	_cycle();
	return pact;
}

const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== "undefined" ? (Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator"))) : "@@iterator";

// Asynchronously iterate through an object's values
// Uses for...of if the runtime supports it, otherwise iterates until length on a copy
function _forOf(target, body, check) {
	if (typeof target[_iteratorSymbol] === "function") {
		var iterator = target[_iteratorSymbol](), step, pact, reject;
		function _cycle(result) {
			try {
				while (!(step = iterator.next()).done && (!check || !check())) {
					result = body(step.value);
					if (result && result.then) {
						if (_isSettledPact(result)) {
							result = result.v;
						} else {
							result.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));
							return;
						}
					}
				}
				if (pact) {
					_settle(pact, 1, result);
				} else {
					pact = result;
				}
			} catch (e) {
				_settle(pact || (pact = new _Pact()), 2, e);
			}
		}
		_cycle();
		if (iterator.return) {
			var _fixup = function(value) {
				try {
					if (!step.done) {
						iterator.return();
					}
				} catch(e) {
				}
				return value;
			};
			if (pact && pact.then) {
				return pact.then(_fixup, function(e) {
					throw _fixup(e);
				});
			}
			_fixup();
		}
		return pact;
	}
	// No support for Symbol.iterator
	if (!("length" in target)) {
		throw new TypeError("Object is not iterable");
	}
	// Handle live collections properly
	var values = [];
	for (var i = 0; i < target.length; i++) {
		values.push(target[i]);
	}
	return _forTo(values, function(i) { return body(values[i]); }, check);
}

const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== "undefined" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator"))) : "@@asyncIterator";

// Asynchronously call a function and send errors to recovery continuation
function _catch(body, recover) {
	try {
		var result = body();
	} catch(e) {
		return recover(e);
	}
	if (result && result.then) {
		return result.then(void 0, recover);
	}
	return result;
}

var MONGOOSE_READYSTATE;

(function (MONGOOSE_READYSTATE) {
  MONGOOSE_READYSTATE[MONGOOSE_READYSTATE["CONNECTED"] = 1] = "CONNECTED";
})(MONGOOSE_READYSTATE || (MONGOOSE_READYSTATE = {}));

var defaultOptions = {
  useNewUrlParser: true,
  useCreateIndex: true
};
var Seeder =
/*#__PURE__*/
function () {
  function Seeder(mongoUrl, options) {
    if (options === void 0) {
      options = defaultOptions;
    }

    this.mongoUrl = mongoUrl;
    this.options = options;
    this.options = _extends({}, defaultOptions, {}, this.options);
  }

  var _proto = Seeder.prototype;

  _proto.connect = function connect() {
    try {
      var _this4 = this;

      var _temp3 = function () {
        if (mongoose.connection.readyState !== MONGOOSE_READYSTATE.CONNECTED) {
          return Promise.resolve(mongoose.connect(_this4.mongoUrl, _this4.options)).then(function () {});
        }
      }();

      return _temp3 && _temp3.then ? _temp3.then(function () {}) : void 0;
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.validateModels = function validateModels(models) {
    try {
      var invalidModels = models.filter(function (model) {
        return !mongoose.modelNames().includes(model);
      });

      if (invalidModels.length) {
        throw new Error('Models not registered in Mongoose: ' + invalidModels);
      }
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.clearModels = function clearModels(modelNames) {
    try {
      var _this5 = this;

      return Promise.resolve(_this5.connect()).then(function () {
        return Promise.resolve(_this5.validateModels(modelNames)).then(function () {
          modelNames.forEach(function (modelName) {
            try {
              return Promise.resolve(mongoose.model(modelName).deleteMany({})).then(function () {
                console.log(modelName + 's collection cleared');
              });
            } catch (e) {
              return Promise.reject(e);
            }
          });
        });
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.populateModels = function populateModels(seedData) {
    try {
      var _this6 = this;

      return Promise.resolve(_this6.connect()).then(function () {
        var seedEntries = Object.entries(seedData);
        var modelNames = seedEntries.reduce(function (modelNames, _ref) {
          var modelName = _ref[0];
          return [].concat(modelNames, [modelName]);
        }, []);
        return Promise.resolve(_this6.validateModels(modelNames)).then(function () {
          return _forOf(seedEntries, function (_ref2) {
            var modelName = _ref2[0],
                documents = _ref2[1];
            var model = mongoose.model(modelName);
            return _forOf(documents, function (document) {
              var _temp2 = _catch(function () {
                return Promise.resolve(model.create(document)).then(function () {});
              }, function () {
                console.error(chalk.red("Error creating document at index " + documents.indexOf(document) + " of " + modelName + " model"));
              });

              if (_temp2 && _temp2.then) return _temp2.then(function () {});
            });
          });
        });
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.disconnect = function disconnect() {
    try {
      return Promise.resolve(mongoose.disconnect()).then(function () {});
    } catch (e) {
      return Promise.reject(e);
    }
  };

  return Seeder;
}();

export { Seeder };
//# sourceMappingURL=mongoose-seed-2.esm.js.map
